/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package reporter;

import reporter.EncounterReporter ;
import community.Community ;
import community.Relationship ;

import java.lang.reflect.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays ;
import java.util.HashMap ;
import java.util.Collections ;
import java.util.Collection ;
import java.util.logging.Level;


/**
 *
 * @author MichaelWalker
 */
public class RelationshipReporter extends Reporter {
    
    static String DEATH = "death" ;
    static String BIRTH = "birth" ;
    static String AGE = "age" ;
    //static String RELATIONSHIP_ID = Relationship.RELATIONSHIP_ID ;
    
    static protected HashMap<String,Object> REPORTS = new HashMap<String,Object>() ;
    
    static protected Collection GET_REPORT_NAMES()
    {
        return REPORTS.keySet() ;
    }
    
    /**
     * If report already in REPORTS then returns it, otherwise generates it from
     * Method prepareReportName() and stores it for later first ;
     * @param reportName
     * @param relationshipReporter
     * @return (Object) Report generated by prepareReportName()
     */
    static protected Object GET_REPORT(String reportName, RelationshipReporter relationshipReporter)
    {
        if (!REPORTS.containsKey(reportName))
        {
            String methodName = "prepare" 
                    + reportName.substring(0,1).toUpperCase() 
                    + reportName.substring(1) ;
            
            try
            {
                Method prepareMethod = RelationshipReporter.class.getDeclaredMethod(methodName) ;
                REPORTS.put(reportName, prepareMethod.invoke(relationshipReporter)) ;
            }
            catch ( Exception e )
            {
                LOGGER.info(e.toString()) ;
            }
            
        }
        return REPORTS.get(reportName) ;
    }
    
    public RelationshipReporter()
    {
        
    }
    
    public RelationshipReporter(String simName, ArrayList<String> report) 
    {
        super(simName, report);
    }

    /**
     * @param simName (String) Root of simulation name.
     * @param reportFilePath (String) Path to saved files.
     */
    public RelationshipReporter(String simName, String reportFilePath)
    {
        super(simName, reportFilePath) ;
    }
    
    /**
     * 
     * @return ArrayList of ArrayLists of (String) RelationshipIds of relationships
     * commenced in each cycle
     */
    public ArrayList<ArrayList<Object>> prepareRelationshipCommenceReport()
    {
        return prepareRelationshipCommenceReport("") ;
    }
    
    public ArrayList<ArrayList<Object>> prepareRelationshipCommenceReport(String relationshipClassName)
    {
        ArrayList<ArrayList<Object>> relationshipCommenceReport = new ArrayList<ArrayList<Object>>() ;
        
        ArrayList<String> commenceReport = prepareCommenceReport() ;
        // Restrict consideration to specified Relationship.class
        if (!relationshipClassName.isEmpty())
            commenceReport = filterReport("relationship",relationshipClassName,RELATIONSHIPID,commenceReport) ;
        
        for (int recordNb = 0 ; recordNb < commenceReport.size() ; recordNb++ )
        {
            String record = commenceReport.get(recordNb) ;
            //LOGGER.info(record);
            //int startIndex = indexOfProperty(RELATIONSHIPID,record) ;
            relationshipCommenceReport.add(extractAllValues(RELATIONSHIPID, record,0)) ;
        }
        return relationshipCommenceReport ;
    }
    
    /**
     * 
     * @return ArrayList of ArrayLists of (String) RelationshipIds of relationships
     * of class relationshipClazz commenced in each cycle
     */
    public ArrayList<ArrayList<Object>> prepareRelationshipCommenceReport(String[] relationshipClazzes)
    {
        ArrayList<ArrayList<Object>> relationshipCommenceReport = new ArrayList<ArrayList<Object>>() ;
        
        ArrayList<String> commenceReport = prepareCommenceReport() ;
        String filteredRecord ;
        
        for (int reportNb = 0 ; reportNb < commenceReport.size() ; reportNb++ )
        {
            String record = commenceReport.get(reportNb) ;
            
            // Include only selected Relationships 
            filteredRecord = "" ;
            for (String relationshipClazz : relationshipClazzes)
                filteredRecord += boundedStringByValue("relationship",relationshipClazz,RELATIONSHIPID,record) ;
            if (filteredRecord.isEmpty())
                filteredRecord = record ;
            //LOGGER.info(record);
            //int startIndex = indexOfProperty(RELATIONSHIPID,record) ;
            relationshipCommenceReport.add(extractAllValues(RELATIONSHIPID, filteredRecord,0)) ;
            //relationshipCommenceReport.add(extractAllValues(AGENTID1, record,0)) ;
        }
        return relationshipCommenceReport ;
    }
    
    /**
     * 
     * @return ArrayList of ArrayLists of (String) RelationshipIds of relationships
     * that break up in each cycle
     */
    public ArrayList<ArrayList<Object>> prepareRelationshipBreakupReport()
    {
        ArrayList<ArrayList<Object>> relationshipBreakupReport = new ArrayList<ArrayList<Object>>() ;
        
        ArrayList<String> breakupReport = prepareBreakupReport() ;
        
        for (int reportNb = 0 ; reportNb < breakupReport.size() ; reportNb++ )
        {
            String report = breakupReport.get(reportNb) ;
            relationshipBreakupReport.add(extractAllValues(RELATIONSHIPID, report,0)) ;
            //relationshipBreakupReport.add(extractAllValues(AGENTID1, record,0)) ;
        }
        return relationshipBreakupReport ;
    }
    
    /**
     * 
     * @return ArrayList of ArrayLists of (String) agentIds of Agents commencing 
     * relationships in each cycle.
     */
    public ArrayList<ArrayList<Object>> prepareAgentCommenceReport()
    {
        ArrayList<ArrayList<Object>> agentCommenceReport = new ArrayList<ArrayList<Object>>() ;
        
        ArrayList<String> commenceReport = prepareCommenceReport() ;
        
        for (int recordNb = 0 ; recordNb < commenceReport.size() ; recordNb++ )
        {
            String record = commenceReport.get(recordNb) ;
            //LOGGER.info(record);
            //int startIndex = indexOfProperty(RELATIONSHIPID,record) ;
            ArrayList<Object> agentCommenceRecord = extractAllValues(AGENTID0,record,0) ;
            agentCommenceRecord.addAll(extractAllValues(AGENTID1,record,0)) ;
            
            agentCommenceReport.add((ArrayList<Object>) agentCommenceRecord.clone()) ;
        }
        return agentCommenceReport ;
    }
    
    /**
     * 
     * @param encounterReporter
     * @return (HashMap) relationshipId maps to number of associated transmissions 
     */
    public HashMap<Object,Number> prepareRelationshipTransmissionReport(EncounterReporter encounterReporter)
    {
        HashMap<Object,Number> relationshipTransmissionReport = new HashMap<Object,Number>() ;
        
        ArrayList<String> encounterReport = encounterReporter.getFullInput() ;
        String encounterRecord ;
        String transmission = "transmission" ;
        ArrayList<String> encounterArray ; 
        ArrayList<Object> transmissionArray ; 
        String[] agentIds ;
        String[] encounterAgentIds ;  // For Agents in encounter
        
        HashMap<Object,String[]> relationshipAgentReport = prepareRelationshipAgentReport() ;
        
        // When did each Relationship commence?
        ArrayList<ArrayList<Object>> relationshipCommenceReport 
                = prepareRelationshipCommenceReport() ;
        // When did each Relationship break-up? Used for efficiency.
        ArrayList<ArrayList<Object>> relationshipBreakupReport 
                = prepareRelationshipBreakupReport() ;
        // relationshipId -> commencement cycle
        ArrayList<Object> currentRelationshipIds = new ArrayList<Object>() ;
        //for (boolean nextInput = true ; nextInput ; nextInput = updateReport())
        int nbCycles = encounterReport.size() ;
        //LOGGER.info(String.valueOf(nbCycles));
        for (int cycle = 0 ; cycle < nbCycles ; cycle++ )
        {
            for (Object relationshipId : relationshipCommenceReport.get(cycle))
                currentRelationshipIds.add(relationshipId) ;
            encounterRecord = encounterReport.get(cycle) ;
            encounterArray = extractArrayList(encounterRecord,transmission) ;
            for (String encounter : encounterArray)
            {
                transmissionArray = extractAllValues(transmission,encounter,0) ;
                if (transmissionArray.contains(TRUE))
                {
                    encounterAgentIds = extractAgentIds(encounter) ;
                    for (Object relationshipId : currentRelationshipIds)
                    {
                        String[] relationshipAgentIds = relationshipAgentReport.get(relationshipId) ;
                        if (relationshipAgentIds[0].equals(encounterAgentIds[0]) && relationshipAgentIds[1].equals(encounterAgentIds[1]))
                        {
                            relationshipTransmissionReport = incrementHashMap(relationshipId,relationshipTransmissionReport) ;
                            continue ;
                        }
                        if (relationshipAgentIds[1].equals(encounterAgentIds[0]) && relationshipAgentIds[0].equals(encounterAgentIds[1]))
                        {
                            relationshipTransmissionReport = incrementHashMap(relationshipId,relationshipTransmissionReport) ;
                            continue ;
                        }
                    }
                }
            }
            for (Object relationshipId : relationshipBreakupReport.get(cycle))
                currentRelationshipIds.remove(relationshipId) ;
            
        }
        return relationshipTransmissionReport ;
    }
    
    /**
     * 
     * @param encounterReporter
     * @return (HashMap) Number of Relationships responsible for a given number 
     * or more transmissions.
     */
    public HashMap<Object,Number> prepareRelationshipCumulativeTransmissionReport(EncounterReporter encounterReporter)
    {
        HashMap<Object,Number> cumulativeRelationshipTransmissionReport = new HashMap<Object,Number>() ;

        HashMap<Object,Number> relationshipTransmissionReport = prepareRelationshipTransmissionReport(encounterReporter) ;
        
        Collection<Number> relationshipTransmissionValues = relationshipTransmissionReport.values() ;
        
        int maxValue = 0 ;
        int intValue = 0 ;
        for (Number value : relationshipTransmissionValues)
        {
            intValue = value.intValue() ;
            if (intValue > maxValue)
                maxValue = intValue ;
        }
        //Collections.max(relationshipTransmissionValues) ;
        
        // To track how agentIds have had more than given Relationships
        int relationshipsOver = 0 ;
        
        for (int key = maxValue ; key > 0 ; key-- )
        {
            relationshipsOver += Collections.frequency(relationshipTransmissionValues,key) ;
            cumulativeRelationshipTransmissionReport.put(key, relationshipsOver) ;
        }
        
        return cumulativeRelationshipTransmissionReport ;
    }        
   
    
    /**
     * Finds last relationshipId entered into for each agentId, then finds last
     * relationshipId broken off that is different from the last entered into
     * @return (HashMap) agentId maps to cycle of last commencement minus that of last 
     * breakup.
     */
    public HashMap<Object,Number> prepareAgentGapReport()
    {
        HashMap<Object,Number> agentGapReport = new HashMap<Object,Number>() ;
        
        // Latest cycle for agentId commencing relationship
        HashMap<Object,Integer> agentLatestCommencement = new HashMap<Object,Integer>() ;
        // Latest cycle for agentId ending relationship different from latest commencement
        HashMap<Object,Integer> agentLatestBreakup = new HashMap<Object,Integer>() ;
        // relaitonshipId of last Relationship to commence for each agentId
        HashMap<Object,String> agentLastRelationship = new HashMap<Object,String>() ;
        
        ArrayList<String> commenceReport = prepareCommenceReport() ;
        ArrayList<String> breakupReport = prepareBreakupReport() ;
        HashMap<Object,String[]> relationshipAgentReport = prepareRelationshipAgentReport() ;
            
        
        String breakupRecord ;
        String relationshipId ;
        String[] agentIds ; 
                
        for (int index = commenceReport.size() - 1 ; index >= 0 ; index-- )
        {
            // Find last Relationship commencement
            String commenceRecord = commenceReport.get(index) ;
            ArrayList<String> relationshipArray = extractArrayList(commenceRecord,RELATIONSHIPID) ;
            for (String relationshipString : relationshipArray)
            {
                for (String propertyName : new String[] {AGENTID0,AGENTID1})
                {
                    Object agentId = extractValue(propertyName,relationshipString) ;
                    if (agentLatestCommencement.putIfAbsent(agentId, index) == null)
                        agentLastRelationship.put(agentId, extractValue(RELATIONSHIPID,relationshipString)) ;
                }
            }
            LOGGER.info(String.valueOf(index));
            // Find last Relationship breakup
            try
            {
                breakupRecord = breakupReport.get(index);
            }
            catch ( Exception e )
            {
                LOGGER.log(Level.INFO,"{0}", breakupReport) ;
                breakupRecord = breakupReport.get(index);
            }
            relationshipArray = extractArrayList(breakupRecord,RELATIONSHIPID) ;
            for (String relationshipString : relationshipArray)
            {
                relationshipId = extractValue(RELATIONSHIPID,relationshipString);
                agentIds = relationshipAgentReport.get(relationshipId) ;
                if (agentIds == null)  // TODO: Make unnecessary by saving and reading burn-in
                    continue ;
                for (String agentId : agentIds)
                    if (!relationshipId.equals(agentLastRelationship.get(agentId)))
                        agentLatestBreakup.putIfAbsent(agentId, index) ;
            }
            
        }
        
        // Find gap between relationships
        for (Object agentId : agentLatestBreakup.keySet())
            agentGapReport.put(agentId, agentLatestCommencement.get(agentId) - agentLatestBreakup.get(agentId)) ;
        
        return agentGapReport ;
    }
    
    /**
     * @return A snapshot of how many agentIds had gaps of a given magnitude 
     * or greater between their final two relationships
     */
    public HashMap<Object,Number> prepareRelationshipCumulativeGapRecord()
    {
        HashMap<Object,Number> cumulativeRelationshipGapRecord = new HashMap<Object,Number>() ;

        HashMap<Object,Number> agentGapReport = prepareAgentGapReport() ;
        
        Collection<Number> agentGapValues = agentGapReport.values() ;
        
        int intValue ;
        int maxValue = 0 ;
        for (Number value : agentGapValues) 
        {
            intValue = value.intValue() ;
            if (intValue > maxValue)
                maxValue = intValue ;
        }
        
        int minValue = maxValue ; 
        for (Number value : agentGapValues)
        {
            intValue = value.intValue() ;
            if (intValue < minValue)
                minValue = intValue ;
        }
        
        // To track how agentIds have had more than given Relationships
        int agentsOver = 0 ;
        
        for (int key = maxValue ; key > 0 ; key-- )
        {
            agentsOver += Collections.frequency(agentGapValues,key) ;
            cumulativeRelationshipGapRecord.put(key, agentsOver) ;
        }
        
        agentsOver = 0 ;
        for (int key = minValue ; key < 0 ; key++ )
        {
            agentsOver += Collections.frequency(agentGapValues,key) ;
            cumulativeRelationshipGapRecord.put(key, agentsOver) ;
        }
        
        return cumulativeRelationshipGapRecord ;
    }
    
    
    /**
     * 
     * @return ArrayList of ArrayLists of (String) AgentIds in a relationship
     * that broke up in a given cycle.
     */
    public ArrayList<ArrayList<String>> prepareAgentBreakupReport()
    {
        ArrayList<ArrayList<String>> agentBreakupReport = new ArrayList<ArrayList<String>>() ;
        ArrayList<String> agentBreakupRecord ;
        ArrayList<String> breakupReport = prepareBreakupReport() ;
        HashMap<Object,String[]> relationshipAgentIds = prepareRelationshipAgentReport() ;
        String record ;
        String relationshipId ;
        String[] agentIds ;
            
        for (int recordNb = 0 ; recordNb < breakupReport.size() ; recordNb++ )
        {
            agentBreakupRecord = new ArrayList<String>() ;
            record = breakupReport.get(recordNb);
            ArrayList<String> relationshipRecords = extractArrayList(RELATIONSHIPID,record) ;
            for (String relationship : relationshipRecords)
            {
                relationshipId = extractValue(RELATIONSHIPID,record);
                agentIds = extractAgentIds(record,0);
                agentBreakupRecord.addAll(Arrays.asList(agentIds));
            }
            agentBreakupReport.add((ArrayList<String>) agentBreakupRecord.clone()) ;
        }
        return agentBreakupReport ;
    }
    
    /**
     * 
     * @return (HashMap) relationshipId -> [agentIds]
     */
    protected HashMap<Object,String[]> prepareRelationshipAgentReport()
    {
        HashMap<Object,String[]> relationshipAgentReport = new HashMap<Object,String[]>() ;
        
        ArrayList<String> commenceReport = prepareCommenceReport() ;
        ArrayList<String> relationshipRecords ;
        String relationshipId ;
        String[] agentIds = new String[2] ;
        
        for (String record : commenceReport)
        {
            relationshipRecords = extractArrayList(record,RELATIONSHIPID) ;
            for (String relationshipRecord : relationshipRecords)
            {
                relationshipId = extractValue(RELATIONSHIPID,relationshipRecord) ;
                agentIds = extractAgentIds(relationshipRecord,0) ;
                relationshipAgentReport.put(relationshipId, agentIds) ;
            }
        }
        return relationshipAgentReport ;
    }
    
    /**
     * 
     * @return (HashMap) length-at-breakup maps to number of Relationships of 
     * corresponding length
     */
    public HashMap<Object,Number> prepareLengthAtBreakupReport()
    {
        HashMap<Object,Number> lengthAtBreakupMap = new HashMap<Object,Number>() ;
        
        // relationshipId -> length of Relationship
        HashMap<Object,Integer> relationshipLengthReport = prepareRelationshipLengthReport() ;
        
        for (Object relationshipId : relationshipLengthReport.keySet())
        {
            int length = relationshipLengthReport.get(relationshipId) ;
            lengthAtBreakupMap = incrementHashMap(length,lengthAtBreakupMap) ;
        }
        
        return lengthAtBreakupMap ;
    }
    
    /**
     * 
     * @return (HashMap) key is String.valueOf(relationshipId) and value is the 
     * number of cycles the corresponding Relationship went for.
     */
    public HashMap<Object,Integer> prepareRelationshipLengthReport()
    {
        HashMap<Object,Integer> relationshipLengthMap = new HashMap<Object,Integer>() ;
        
        ArrayList<ArrayList<Object>> relationshipCommenceReport = prepareRelationshipCommenceReport() ;
        ArrayList<ArrayList<Object>> relationshipBreakupReport = prepareRelationshipBreakupReport() ;
        
        // Which Relationships commenced in cycle index
        for (int index = 0 ; index < relationshipCommenceReport.size() ; index++ )
        {
            ArrayList<Object> commenceRecord = relationshipCommenceReport.get(index) ;
            
            for (Object relationshipId : commenceRecord)
                relationshipLengthMap.put(relationshipId, -index) ;
        }
        for (int index = 0 ; index < (relationshipBreakupReport.size() ) ; index++ )
        {
            // key relationshipId must have commenced already, with value -ve start cycle
            ArrayList<Object> breakupRecord = relationshipBreakupReport.get(index) ;
            
            for (Object relationshipId : breakupRecord)
            {
                int commenceIndex = relationshipLengthMap.get(relationshipId) ;
                relationshipLengthMap.put(relationshipId, index + commenceIndex + 1) ;    // +1 because breakup is done in same cycle
            }
        }
        
        // RelationshipLengthMap < 0 for Relationships that are still ongoing at the end of the simulation.
        for (Object relationshipId : relationshipLengthMap.keySet())
            if (!(relationshipLengthMap.get(relationshipId) > 0))
            {
                int newValue = relationshipLengthMap.get(relationshipId) + Integer.valueOf(getMetaDatum("Community.MAX_CYCLES")) + 1 ;
                relationshipLengthMap.put(relationshipId, newValue) ;
            }
        
        return relationshipLengthMap ;
    }
    
    /**
     * 
     * @return Report of mean of minimum number of each subclass of Relationship 
     * to date.
     */
    public ArrayList<HashMap<Object,Object>> prepareMeanCumulativeRelationshipReport(String[] relationshipClassNames)
    {
        ArrayList<HashMap<Object,Object>> meanCumulativeRelationshipReport 
                = new ArrayList<HashMap<Object,Object>>() ;
        
        HashMap<Object,Object> meanCumulativeRelationshipClassReport ;
        
        int population = Integer.valueOf(getMetaDatum("Community.POPULATION")) ;
        
        ArrayList<HashMap<Object,HashMap<Object,Integer>>> agentsCumulativeRelationshipReport 
                = prepareAgentsCumulativeRelationshipReport(relationshipClassNames) ;
        
        for (HashMap<Object,HashMap<Object,Integer>> record : agentsCumulativeRelationshipReport)
        {
            meanCumulativeRelationshipClassReport = new HashMap<Object,Object>() ;
            for (Object relationshipClassName : record.keySet())
            {
                int sum = 0 ;
                for (Object agentId : record.get(relationshipClassName).keySet())
                    sum += record.get(relationshipClassName).get(agentId) ;
                meanCumulativeRelationshipClassReport.put(relationshipClassName,((double) sum)/population) ; // record.keySet().size()) ;
            }
            meanCumulativeRelationshipReport.add((HashMap<Object,Object>) meanCumulativeRelationshipClassReport.clone()) ;
        }
        return meanCumulativeRelationshipReport ;
    }
    
    /**
     * TODO: Include length one and then plot on a log-scale.
     * @return A snapshot of how many agentIds have more had how many or more Relationships
     */
    public HashMap<Object,Number> prepareCumulativeLengthReport()
    {
        HashMap<Object,Number> cumulativeRelationshipLengthReport = new HashMap<Object,Number>() ;
        
        //TODO: Separate out action on individual RECORD
        //ArrayList<HashMap<Object,Integer>> agentsCumulativeRelationshipReport 
          //      = prepareAgentsCumulativeRelationshipReport() ;
        
        HashMap<Object,Number> lengthAtBreakupReport = prepareLengthAtBreakupReport() ;
        
        // Find maximum relationship length
        int maxValue = 0 ;
        int lengthValue ;
        for (Object lengthObject : lengthAtBreakupReport.keySet())
        {
            lengthValue = Integer.valueOf(String.valueOf(lengthObject)) ;
            if (lengthValue > maxValue)
                maxValue = lengthValue ;
        }
        
        int relationshipsUnder = 0 ;
        for (int lengthKey = maxValue ; lengthKey > 1 ; lengthKey-- )
        {
            if (lengthAtBreakupReport.containsKey(lengthKey))
                relationshipsUnder += (Integer) lengthAtBreakupReport.get(lengthKey) ;
            cumulativeRelationshipLengthReport.put(lengthKey, relationshipsUnder) ;
        }
        return cumulativeRelationshipLengthReport ;
    }
    
    /**
     * @return A snapshot of how many agentIds have more had how many or more Relationships
     */
    public HashMap<Object,HashMap<Object,Number>> prepareCumulativeRelationshipRecord(String[] relationshipClassNames)
    {
        HashMap<Object,HashMap<Object,Number>> cumulativeRelationshipRecord 
                = new HashMap<Object,HashMap<Object,Number>>() ;
        for (String relationshipClassName : relationshipClassNames)
            cumulativeRelationshipRecord.put(relationshipClassName, new HashMap<Object,Number>()) ;
        
        //TODO: Separate out action on individual RECORD
        ArrayList<HashMap<Object,HashMap<Object,Integer>>> agentsCumulativeRelationshipReport 
                = prepareAgentsCumulativeRelationshipReport(relationshipClassNames) ;
        
        HashMap<Object,HashMap<Object,Integer>> agentsCumulativeRelationshipRecord 
                = agentsCumulativeRelationshipReport.get(agentsCumulativeRelationshipReport.size()-1) ;
        
        
        for (Object relationshipClassName : relationshipClassNames)
        {
            Collection<Integer> agentsCumulativeRelationshipValues 
                    = agentsCumulativeRelationshipRecord.get(relationshipClassName).values() ;

            int maxValue = Collections.max(agentsCumulativeRelationshipValues) ;

            // To track how agentIds have had more than given Relationships
            int agentsOver = 0 ;

            for (int key = maxValue ; key > 0 ; key-- )
            {
                agentsOver += Collections.frequency(agentsCumulativeRelationshipValues,key) ;
                cumulativeRelationshipRecord.get(relationshipClassName).put(key, agentsOver) ;
            }
        }
        return cumulativeRelationshipRecord ;
    }
    
    /**
     * 
     * @return Report with relationshipClassName maps to 
     * (HashMap showing how many Relationships each agentId has entered into so far).
     */
    private ArrayList<HashMap<Object,HashMap<Object,Integer>>> 
        prepareAgentsCumulativeRelationshipReport(String[] relationshipClassNames)
    {
        ArrayList<HashMap<Object,HashMap<Object,Integer>>> agentsCumulativeRelationshipReport 
                = new ArrayList<HashMap<Object,HashMap<Object,Integer>>>() ;
        
        // Keeps track of cumulative number of Relationships per agentId
        HashMap<Object,HashMap<Object,Integer>> agentCumulativeRelationships 
                = new HashMap<Object,HashMap<Object,Integer>>() ;
        for (String relationshipClassName : relationshipClassNames)
            agentCumulativeRelationships.put(relationshipClassName, new HashMap<Object,Integer>()) ;
        
        ArrayList<HashMap<Object,HashMap<Object,ArrayList<Object>>>> agentsEnteredRelationshipReport 
                = prepareAgentsEnteredRelationshipReport(relationshipClassNames) ;
        
        for (HashMap<Object,HashMap<Object,ArrayList<Object>>> record : agentsEnteredRelationshipReport )
        {
            for (Object relationshipClassName : relationshipClassNames)
            {
                for (Object agentId : record.get(relationshipClassName).keySet())
                {
                    int sumSoFar = 0 ;
                    if (agentCumulativeRelationships.get(relationshipClassName).containsKey(agentId))
                        sumSoFar = agentCumulativeRelationships.get(relationshipClassName).get(agentId) ;
                    agentCumulativeRelationships.get(relationshipClassName).put(agentId, record.get(relationshipClassName).get(agentId).size() + sumSoFar) ;
                }
            }
            agentsCumulativeRelationshipReport.add(agentCumulativeRelationships) ;
        }
        return agentsCumulativeRelationshipReport ;
    }
    
    /**
     * 
     * @return (ArrayList) records of mean number of each Relationship class per Agent
     */
    public ArrayList<HashMap<Object,Number>> prepareMeanNumberRelationshipsReport(String[] relationshipClassNames)
    {
        ArrayList<HashMap<Object,Number>> meanNumberRelationshipsReport = new ArrayList<HashMap<Object,Number>>() ;
        
        HashMap<Object,Object> meanRelationshipClassReport = new HashMap<Object,Object>() ;
        
        //ArrayList<Object> populationReport = (new PopulationReporter("",input)).preparePopulationReport() ;
        
        ArrayList<HashMap<Object,HashMap<Object,Integer>>> agentNumberRelationshipsReport
                = prepareAgentNumberRelationshipsReport(relationshipClassNames) ;
        int population = Integer.valueOf(getMetaDatum("Community.POPULATION")) ; // = Integer.valueOf(extractValue("Population", (String) populationReport.get(recordIndex))) ;

        //for (int recordIndex = 0 ; recordIndex < agentNumberRelationshipsReport.size() ; recordIndex++ )
        //{
        for ( HashMap<Object,HashMap<Object,Integer>> record : agentNumberRelationshipsReport) // .get(recordIndex) ;
        {
            // Loop over Relationship classes
            for (Object relationshipClassName : record.keySet())
            {
                int sum = 0 ;
                meanRelationshipClassReport = new HashMap<Object,Object>() ;
                // Sum over Agents
                for (Object agentId : record.get(relationshipClassName).keySet())
                    sum += record.get(relationshipClassName).get(agentId) ; // Integer.valueOf(String.valueOf(number)) ;
   
                meanRelationshipClassReport.put(relationshipClassName,((double) sum)/population) ;  // (Object) "Mean number of partners:" + 
            }
            meanNumberRelationshipsReport.add((HashMap<Object,Number>) meanRelationshipClassReport.clone()) ;
        }
        return meanNumberRelationshipsReport ;
    }
    
    /**
     * First count the number of Relationships each Agent has entered up to now,
     * then subtract those which have broken up.
     * TODO: Redo to account for burn-in relationships.
     * @return Each record gives relationshipClassName maps to 
     * (the number of current Relationships for each Agent).
     */
    public ArrayList<HashMap<Object,HashMap<Object,Integer>>> prepareAgentNumberRelationshipsReport(String[] relationshipClassNames) 
    {
        ArrayList<HashMap<Object,HashMap<Object,Integer>>> agentNumberRelationshipsReport 
                = new ArrayList<HashMap<Object,HashMap<Object,Integer>>>() ;
        
        ArrayList<HashMap<Object,HashMap<Object,Integer>>> agentEnterRelationshipsReport 
                = new ArrayList<HashMap<Object,HashMap<Object,Integer>>>() ;
        
        ArrayList<HashMap<Object,HashMap<Object,Integer>>> agentBreakupRelationshipsReport 
                = new ArrayList<HashMap<Object,HashMap<Object,Integer>>>() ;
        
        // ArrayList of relationshipClassName maps to (agentId maps to relationshipIds)
        ArrayList<HashMap<Object,HashMap<Object,ArrayList<Object>>>> agentsEnteredRelationshipReport 
                = prepareAgentsEnteredRelationshipReport(relationshipClassNames) ;
        
        // relationshipId maps to relationshipClassName ;
        HashMap<Object,String> relationshipClazzReport = prepareRelationshipClazzReport() ;
        
        
        ArrayList<String> breakupReport = prepareBreakupReport() ;
    
        // relationshipClassName maps to (agentId maps to relationshipIds)
        HashMap<Object,HashMap<Object,ArrayList<Object>>> agentRelationships 
                = new HashMap<Object,HashMap<Object,ArrayList<Object>>>() ;
        for (Object relationshipClassName : relationshipClassNames)
            agentRelationships.put(relationshipClassName, new HashMap<Object,ArrayList<Object>>()) ;
        
        //LOGGER.log(Level.INFO, "{0}", agentsEnteredRelationshipReport);
        int reportsSize = agentsEnteredRelationshipReport.size() ;
        
        // RelationshipClassName maps to (agentId maps to Relationship count) 
        HashMap<Object,HashMap<Object,Integer>> agentRelationshipsCount = new HashMap<Object,HashMap<Object,Integer>>() ;
        for (Object relationshipClassName : relationshipClassNames)
            agentRelationshipsCount.put(relationshipClassName, new HashMap<Object,Integer>()) ;
        
        for (int enteredIndex = 0 ; enteredIndex < reportsSize ; enteredIndex++ )
        {
            for (Object relationshipClassName : relationshipClassNames)
            {    
                // Formation of new Relationships
                HashMap<Object,HashMap<Object,ArrayList<Object>>> enteredRecord 
                        = agentsEnteredRelationshipReport.get(enteredIndex) ;
                
                HashMap<Object,ArrayList<Object>> agentsRelationshipClassRecord 
                        = enteredRecord.get(relationshipClassName) ;
                
                if (agentsRelationshipClassRecord.size() > 0)
                    for (Object agentId : agentsRelationshipClassRecord.keySet())
                    {
                        //LOGGER.info(String.valueOf(agentId)) ;
                        // Number of new Relationships
                        int newTotal = agentsRelationshipClassRecord.get(agentId).size() ;

                        // Plus ones already formed
                        if (agentRelationshipsCount.get(relationshipClassName).containsKey(agentId))
                            newTotal += agentRelationshipsCount.get(relationshipClassName).get(agentId) ;
                        agentRelationshipsCount.get(relationshipClassName).put(agentId, newTotal) ;
                        //LOGGER.log(Level.INFO, "{0}", agentRelationshipsCount);

                        for (Object relationshipId : agentsRelationshipClassRecord.get(agentId))
                            agentRelationships.put(relationshipClassName, 
                                    updateHashMap(relationshipId,agentId,agentRelationships.get(relationshipClassName))) ;
                    }
            }
            HashMap<Object,HashMap<Object,Integer>> enterAgentRelationshipsCount = (HashMap<Object,HashMap<Object,Integer>>) agentRelationshipsCount.clone() ;
            agentEnterRelationshipsReport.add(enterAgentRelationshipsCount) ;
        }
        
        // relationshipCLassName maps to (Count number of broken-up Relationships of each Agent.)
        HashMap<Object,HashMap<Object,Number>> agentBreakupsCount 
                = new HashMap<Object,HashMap<Object,Number>>() ;
        for (String relationshipClassName : relationshipClassNames)
            agentBreakupsCount.put(relationshipClassName, new HashMap<Object,Number>()) ;
        
        for (int breakupIndex = 0 ; breakupIndex < (reportsSize-1) ; breakupIndex++ )
        {
            // Formation of new Relationships
            String breakupRecord = breakupReport.get(breakupIndex) ; // agentsBreakupRelationshipReport.get(breakupIndex) ;
            //for (Object agentId : breakupRecord.keySet())
            for (Object relationshipId : extractAllValues(RELATIONSHIPID,breakupRecord,0)) 
            {
                // Relationship breakups
                Object relationshipClassName = extractValue("relationship",relationshipClazzReport.get(relationshipId)) ;
                
                for (Object agentId : agentRelationships.get(relationshipClassName).get(relationshipId))
                {
                //int subtractTotal = breakupRecord.get(agentId).size() ;
                    agentBreakupsCount.put(relationshipClassName,incrementHashMap(agentId,agentBreakupsCount.get(relationshipClassName))) ;
                
//                if (agentBreakupsCount.containsKey(agentId))
//                {
//                    // Plus ones already formed
//                    subtractTotal += agentBreakupsCount.get(agentId) ;
//                }
//                agentBreakupsCount.put(agentId, subtractTotal) ;
                }
            
            }
            agentBreakupRelationshipsReport.add((HashMap<Object,HashMap<Object,Integer>>) agentBreakupsCount.clone()) ;
        }
        
        // Subtract broken-up Relationships from commenced Relationships for each Agent.
        for (int breakupIndex = 0 ; breakupIndex < (reportsSize-1) ; breakupIndex++ )
        {
            HashMap<Object,HashMap<Object,Integer>> numberRelationshipsCount = new HashMap<Object,HashMap<Object,Integer>>() ;
            HashMap<Object,HashMap<Object,Integer>> enterRecord = agentEnterRelationshipsReport.get(breakupIndex+1) ;
            HashMap<Object,HashMap<Object,Integer>> breakupRecord = agentBreakupRelationshipsReport.get(breakupIndex) ;
            
            for (Object relationshipClassName : relationshipClassNames)
            {
                numberRelationshipsCount.put(relationshipClassName, new HashMap<Object,Integer>()) ;
                for (Object agentId : breakupRecord.get(relationshipClassName).keySet())
                {
    //                if (!enterRecord.containsKey(agentId))
    //                    continue ;  // Relationship entered during burn-in
                    try
                    {
                        numberRelationshipsCount.get(relationshipClassName).
                                put(agentId, enterRecord.get(relationshipClassName).get(agentId) - breakupRecord.get(relationshipClassName).get(agentId)) ;
                    }
                    catch (Exception e)
                    {
                        LOGGER.info(String.valueOf(agentId));
                        numberRelationshipsCount.get(relationshipClassName).
                                put(agentId, enterRecord.get(relationshipClassName).get(agentId) - breakupRecord.get(relationshipClassName).get(agentId)) ;
                    }
                }
            }
            agentNumberRelationshipsReport.add((HashMap<Object,HashMap<Object,Integer>>) numberRelationshipsCount.clone()) ;
        }
        return agentNumberRelationshipsReport ;
    }
    
    /**
     * Indicates which Agents were infected at which Sites for which cycles.
     * TODO: Adapt to multiple Report files
     * @param siteNames
     * @return HashMap key agentId, value HashMap key siteName value ArrayList of cycles when infected
     */
    private HashMap<Object,HashMap<Object,ArrayList<Object>>> prepareAgentInfectionReport(String[] siteNames)
    {
        HashMap<Object,HashMap<Object,ArrayList<Object>>> agentInfectionReport = new HashMap<Object,HashMap<Object,ArrayList<Object>>>() ;

        HashMap<Object,ArrayList<Integer>> siteInfectionReport ;

        for (int recordIndex = 0 ; recordIndex < input.size() ; recordIndex++ )
        {
            String record = input.get(recordIndex) ; 
            ArrayList<String> agentIdArray = extractArrayList(record,AGENTID) ;
            for ( String agentString : agentIdArray )
            {
                String agentId = extractValue(AGENTID,agentString) ;
                //siteInfectionReport = agentInfectionReport.get(agentId) ;
                for ( String siteName : siteNames )
                    if (record.indexOf(siteName) > 0 )
                        agentInfectionReport = updateHashMap(agentId,siteName,recordIndex,agentInfectionReport) ;
            }
        }
        return agentInfectionReport ;
    }
    
    /**
     * 
     * @return Each record is a HashMap indicating new relationshipIds for relevant (key) Agents
     */
    public ArrayList<HashMap<Object,HashMap<Object,ArrayList<Object>>>> 
        prepareAgentsEnteredRelationshipReport(String[] relationshipClassNames)
    {
        return prepareAgentsEnteredRelationshipReport(relationshipClassNames,0,0,Integer.valueOf(getMetaDatum("Community.MAX_CYCLES"))) ;
    }
    
    /**
     * 
     * @param backYears
     * @param backMonths
     * @param backDays
     * @return Each record is a HashMap where relationshipClassName maps to a 
     * HashMap indicating new relationshipIds for relevant (key) Agents
     */
    public ArrayList<HashMap<Object,HashMap<Object,ArrayList<Object>>>> 
        prepareAgentsEnteredRelationshipReport(String[] relationshipClassNames, int backYears, int backMonths, int backDays)
    {
        ArrayList<HashMap<Object,HashMap<Object,ArrayList<Object>>>> agentsEnteredRelationshipReport 
                = new ArrayList<HashMap<Object,HashMap<Object,ArrayList<Object>>>>() ; 
        
        HashMap<Object,String[]> relationshipAgentReport = prepareRelationshipAgentReport() ;
        
        // How many cycles far back do we count?
        int maxCycles = Integer.valueOf(getMetaDatum("Community.MAX_CYCLES")) ;
        int backCycles = getBackCycles(backYears, backMonths, backDays, maxCycles) ;
        
        ArrayList<String> commenceReport = prepareCommenceReport() ;
        
        HashMap<Object,HashMap<Object,ArrayList<Object>>> commenceRelationshipRecord 
                = new HashMap<Object,HashMap<Object,ArrayList<Object>>>();
        for (String relationshipClassName : relationshipClassNames)
            commenceRelationshipRecord.put(relationshipClassName, new HashMap<Object,ArrayList<Object>>()) ;
        
        for (int recordIndex = maxCycles - 1 ; recordIndex >= (maxCycles - backCycles) ; recordIndex-- )
        {
            String record = commenceReport.get(recordIndex) ;
            
            commenceRelationshipRecord = new HashMap<Object,HashMap<Object,ArrayList<Object>>>();
            for (String relationshipClassName : relationshipClassNames)
                commenceRelationshipRecord.put(relationshipClassName, new HashMap<Object,ArrayList<Object>>()) ;
            ArrayList<String> relationshipIdArray = extractArrayList(record,RELATIONSHIPID) ;
            for (String relationshipString : relationshipIdArray)
            {
                Object relationshipIdValue = extractValue(RELATIONSHIPID,relationshipString) ;
                String relationshipClassName = extractValue("relationship",relationshipString) ;
                if (!commenceRelationshipRecord.containsKey(relationshipClassName)) 
                    continue ;
                Object[] agentIdValues = relationshipAgentReport.get(relationshipIdValue) ; 
                
                //String agentId0Value = extractValue(AGENTID0,relationshipString) ;
                commenceRelationshipRecord.put(relationshipClassName,
                        updateHashMap(agentIdValues[0],relationshipIdValue,commenceRelationshipRecord.get(relationshipClassName))) ;
                
                //String agentId1Value = extractValue(AGENTID1,relationshipString) ;
                commenceRelationshipRecord.put(relationshipClassName,
                        updateHashMap(agentIdValues[1],relationshipIdValue,commenceRelationshipRecord.get(relationshipClassName))) ;
            }
            
            agentsEnteredRelationshipReport.add(0,(HashMap<Object,HashMap<Object,ArrayList<Object>>>) commenceRelationshipRecord.clone()) ;
            
        }
        return agentsEnteredRelationshipReport ;
    }
    
    /**
     * TODO: Change entering to being in
     * @param backYears
     * @param backMonths
     * @param backDays
     * @return (HashMap) Relationship class maps to number of Agents entering such
     * Relationship during given time.
     */
    public HashMap<Object,Number> 
        prepareNumberAgentsEnteredRelationshipReport(String[] relationshipClassNames, int backYears, int backMonths, int backDays)
    {
        HashMap<Object,Number> agentsEnteredRelationshipReport = new HashMap<Object,Number>() ;
        
        // (HashMap) relationshipClassName maps to (agentIds maps to number of new Relationships in given time).
        HashMap<Object,HashMap<Object,Integer>> numberRecentRelationshipsReport 
                = prepareNumberRecentRelationshipsReport(relationshipClassNames, backYears, backMonths, backDays) ;
        
        for (Object relationshipClassName : relationshipClassNames )  // numberRecentRelationshipsReport.keySet())
            agentsEnteredRelationshipReport.put(relationshipClassName, numberRecentRelationshipsReport.get(relationshipClassName).keySet().size()) ;
    
        return agentsEnteredRelationshipReport ;
    }
    
    /**
     * Filters Relationships in fullReport records to be class relationshipClazzName
     * @param relationshipClazzName
     * @param fullReport
     * @return 
     */
    protected ArrayList<String> filterRelationshipClazzReport(String relationshipClazzName, ArrayList<String> fullReport)
    {
        if (relationshipClazzName.isEmpty())
            return fullReport ;
        
        ArrayList<String> relationshipClazzReport = new ArrayList<String>() ;
        
        HashMap<Object,String> relationshipReport = prepareRelationshipClazzReport() ;
        String relationshipId ;
        String filteredRecord ;
        
        for (String record : fullReport)
        {
            filteredRecord = "" ;
            ArrayList<String> encounterRecords = extractArrayList(record,RELATIONSHIPID) ;
            for (String encounter : encounterRecords)
            {
                relationshipId = extractValue(RELATIONSHIPID,encounter) ; 
                if (compareValue("relationship",relationshipClazzName,relationshipReport.get(relationshipId))) 
                    filteredRecord = filteredRecord + encounter ;
            }
            relationshipClazzReport.add(filteredRecord) ;
        }
        
        return relationshipClazzReport ;
    }
    
    /**
     * Filters Relationship entries in fullReport to be con/dis-cordant with respect
     * to propertyName.
     * @param propertyName
     * @param concordant
     * @param fullReport
     * @return (ArrayList) String records including only appropriately con/dis-cordant
     * Relationship entries
     */
    protected ArrayList<String> filterByConcordance(String propertyName, boolean concordant, ArrayList<String> fullReport)
    {
        if (propertyName.isEmpty())
            return fullReport ;
        
        ArrayList<String> filteredReport = new ArrayList<String>() ;
        
        String filteredRecord ;
        
        HashMap<Object,String> relationshipConcordanceReport = prepareRelationshipConcordanceReport(propertyName) ;
        
        for (String fullRecord : fullReport)
        {
            ArrayList<String> relationshipList = extractArrayList(fullRecord,RELATIONSHIPID) ;
            filteredRecord = "" ;
            
            for (String relationshipEntry : relationshipList)
            {
                String relationshipId = extractValue(RELATIONSHIPID,relationshipEntry) ;
                String concordanceString = relationshipConcordanceReport.get(relationshipId) ;
                if (compareValue(propertyName,String.valueOf(concordant),concordanceString))
                    filteredRecord += relationshipEntry ;
            }
            filteredReport.add(filteredRecord) ;
        }
        return filteredReport ;
    }
    
    /**
     * Prepares report on whether Agents in a Relationship are concordant with 
     * regards to propertyName.
     * @param propertyName
     * @return (HashMap) relationshipId maps to String describing boolean concordance
     * of propertName between involved Agents.
     */
    public HashMap<Object,String> prepareRelationshipConcordanceReport(String propertyName)
    {
        HashMap<Object,String> relationshipConcordanceReport = new HashMap<Object,String>() ; 
        String concordanceString ;
        
        HashMap<Object,String[]> relationshipAgentReport = prepareRelationshipAgentReport() ;
        
        ArrayList<String[]> relationshipAgentsList = new ArrayList<String[]>() ;
        
        PopulationReporter populationReporter = new PopulationReporter(simName,getFolderPath()) ;
        
        HashMap<String[],Boolean> concordanceBoolean ;
        
        for (String[] pair : relationshipAgentReport.values())
            relationshipAgentsList.add(pair) ;
        
        concordanceBoolean = populationReporter.getConcordants(propertyName,relationshipAgentsList) ;
        
        for (Object relationshipId : relationshipAgentReport.keySet())
        {
            String[] concordanceKey = relationshipAgentReport.get(relationshipId) ;
            concordanceString = Reporter.addReportProperty(propertyName, concordanceBoolean.get(concordanceKey)) ;
            relationshipConcordanceReport.put(relationshipId, concordanceString) ;
        }
        
        return relationshipConcordanceReport ;
    }
    
    /**
     * 
     * @return (HashMap) relationshipId maps to String describing boolean concordance between
     * involved Agents.
     */
    public HashMap<Object,String> prepareRelationshipConcordantsReport()
    {
        HashMap<Object,String> relationshipConcordantsReport = new HashMap<Object,String>() ;
        
        HashMap<Object,String[]> relationshipAgentReport = prepareRelationshipAgentReport() ;
        
        String concordantOutput ;
        String value0 ;
                
        PopulationReporter populationReporter = new PopulationReporter(simName,getFolderPath()) ;
        
        // Identify census properties for all Agents.
        HashMap<Object,String> censusPropertyReport = populationReporter.prepareCensusPropertyReport() ;
        
        ArrayList<String> censusProperties = identifyProperties(censusPropertyReport.get("0")) ;
        for (Object relationshipId : relationshipAgentReport.keySet())
        {
            String[] agentIds = relationshipAgentReport.get(relationshipId) ;
            String censusRecord0 = censusPropertyReport.get(agentIds[0]) ;
            String censusRecord1 = censusPropertyReport.get(agentIds[1]) ;
            concordantOutput = "" ;
            for (String propertyName : censusProperties)
            {
                value0 = extractValue(propertyName,censusRecord0);
                concordantOutput += addReportProperty(propertyName,compareValue(propertyName,value0,censusRecord1)) ;
            }
            relationshipConcordantsReport.put(relationshipId, concordantOutput) ;
        }
        return relationshipConcordantsReport ;
    }
    
    /**
     * 
     * @return (HashMap) relationshipId maps to relationship.subclass.getName()
     */
    protected HashMap<Object,String> prepareRelationshipClazzReport()
    {
        HashMap<Object,String> relationshipClazzReport = new HashMap<Object,String>() ; 
        
        ArrayList<String> commenceReport = prepareCommenceReport() ;
        
        String relationshipRecord ; 
        String relationshipClassName ;
        
        for (String record : commenceReport)
        {
            ArrayList<String> relationshipEntries = extractArrayList(record,RELATIONSHIPID) ;
            
            for (String entry : relationshipEntries)
            {
                relationshipRecord = "" ;
                String relationshipId = extractValue(RELATIONSHIPID,entry) ;
                relationshipClassName = extractValue("relationship",entry) ;
                relationshipRecord += addReportProperty("relationship",relationshipClassName) ;
                relationshipClazzReport.put(relationshipId,relationshipRecord) ;
            }
        }
        return relationshipClazzReport ;
    }
    
    /**
     * 
     * @param backYears
     * @param backMonths
     * @param backDays
     * @return (HashMap) number of new Relationships in given period maps to number
     * of Agents who had that many Relationships during that period.
     */
    public HashMap<Object,HashMap<Object,Number>> 
        prepareRecentRelationshipsReport(String[] relationshipClassNames, int backYears, int backMonths, int backDays)
    {
        HashMap<Object,HashMap<Object,Number>> recentRelationshipsReport = new HashMap<Object,HashMap<Object,Number>>() ; 
         
        // (HashMap) agentIds maps to number of new Relationships in given time.
        HashMap<Object,HashMap<Object,Integer>> numberRecentRelationshipsReport 
                  = prepareNumberRecentRelationshipsReport(relationshipClassNames, backYears, backMonths, backDays) ;
        
        // How many cycles far back do we count?
        int maxCycles = Integer.valueOf(getMetaDatum("Community.MAX_CYCLES")) ;
        int backCycles = getBackCycles(backYears, backMonths, backDays, maxCycles) ;
        
        PopulationReporter populationReporter = new PopulationReporter(simName,getFolderPath()) ;
        ArrayList<Object> agentsAlive = populationReporter.prepareAgentsAliveRecord(backCycles) ;
        
        int newRelationships ;
        
        for (Object relationshipClassName : numberRecentRelationshipsReport.keySet())
        {
            for (Object agentId : agentsAlive)
            {
                if (numberRecentRelationshipsReport.get(relationshipClassName).keySet().contains(agentId))
                    newRelationships = numberRecentRelationshipsReport.get(relationshipClassName).get(agentId);
                else
                    newRelationships = 0 ;

                recentRelationshipsReport.put(relationshipClassName,
                        incrementHashMap((Object) newRelationships,recentRelationshipsReport.get(relationshipClassName))) ;
            }
        }
          
        return recentRelationshipsReport ;
    }
    
    /**
     * 
     * @param backYears
     * @param backMonths
     * @param backDays
     * @return (HashMap) relationshipClassName maps to 
     * (agentIds maps to number of new Relationships in given time).
     */
    private HashMap<Object,HashMap<Object,Integer>> 
        prepareNumberRecentRelationshipsReport(String[] relationshipClassNames, int backYears, int backMonths, int backDays)
    {
        HashMap<Object,HashMap<Object,Integer>> numberRecentRelationshipsReport = new HashMap<Object,HashMap<Object,Integer>>() ;
        for (String relationshipClassName : relationshipClassNames)
            numberRecentRelationshipsReport.put(relationshipClassName, new HashMap<Object,Integer>()) ;
        
        // Each record is a HashMap indicating new relationshipIds for relevant (key) Agents
        ArrayList<HashMap<Object,HashMap<Object,ArrayList<Object>>>> agentsEnteredRelationshipReport 
                = prepareAgentsEnteredRelationshipReport(relationshipClassNames,backYears,backMonths,backDays) ;
        int newRelationships ;
                
        for (HashMap<Object,HashMap<Object,ArrayList<Object>>> record : agentsEnteredRelationshipReport)
            for (Object relationshipClassName : record.keySet())
                for (Object agentId : record.get(relationshipClassName).keySet())
                {
                    newRelationships = record.get(relationshipClassName).get(agentId).size();
                    numberRecentRelationshipsReport.put(relationshipClassName,
                            updateHashMap(agentId,newRelationships,numberRecentRelationshipsReport.get(relationshipClassName))) ;
                }
            
        return numberRecentRelationshipsReport ;
    }
    
    /**
     * 
     * @return Each record is a HashMap indicating breakup of relationshipIds for relevant (key) agentIds
     */
    private ArrayList<HashMap<Object,ArrayList<Object>>> prepareAgentsBreakupRelationshipReport()
    {
        ArrayList<HashMap<Object,ArrayList<Object>>> agentsBreakupRelationshipReport = new ArrayList<HashMap<Object,ArrayList<Object>>>() ;
        
        ArrayList<String> breakupReport = prepareBreakupReport() ;
        
        HashMap<Object,ArrayList<Object>> breakupRelationshipRecord ;
        
        for (String record : breakupReport)
        {
            breakupRelationshipRecord = new HashMap<Object,ArrayList<Object>>();
            
            ArrayList<String> relationshipIdArray = extractArrayList(record,RELATIONSHIPID) ;
            for (String relationshipString : relationshipIdArray)
            {
                String relationshipIdValue = extractValue(RELATIONSHIPID,relationshipString) ;
                
                String agentId0Value = extractValue(AGENTID0,relationshipString) ;
                if (!agentId0Value.isEmpty())
                    breakupRelationshipRecord = updateHashMap(agentId0Value,relationshipIdValue,breakupRelationshipRecord,false) ;
                
                String agentId1Value = extractValue(AGENTID1,relationshipString) ;
                if (!agentId1Value.isEmpty())
                    breakupRelationshipRecord = updateHashMap(agentId1Value,relationshipIdValue,breakupRelationshipRecord,false) ;
            }
            
            agentsBreakupRelationshipReport.add(breakupRelationshipRecord) ;
            
        }
        return agentsBreakupRelationshipReport ;
    }
    
    
    private ArrayList<String> prepareBreakupReport()
    {
        return prepareBreakupReport(true) ;
    }
    
    /**
     * 
     * @return Report with breakup-relevant information from input records.
     */
    private ArrayList<String> prepareBreakupReport(boolean readBurnin)
    {
        ArrayList<String> breakupReport = new ArrayList<String>() ;
        
        String record ;
        int breakupIndex ;
        String valueString ;

        //Include burn-in Relationships
        ArrayList<String> inputString = new ArrayList<String>() ;
        if (readBurnin || !Relationship.BURNIN_BREAKUP.isEmpty())
            breakupReport.add("clear:") ;
        
        for (boolean nextInput = true ; nextInput ; nextInput = updateReport() )
            for (int recordNb = 0 ; recordNb < input.size() ; recordNb += outputCycle )
            {
                record = input.get(recordNb) ;
                record = record.substring(record.indexOf("clear:")) ;
                //LOGGER.log(Level.INFO, "{0} {1}", new Object[] {recordNb,record});

                breakupReport.add(record) ;
            }
        return breakupReport ;
    }
    
    /**
     * 
     * @return Report with commence-relevant information from input records.
     * Includes Relationships commenced during burn-in that breakup during the
     * simulation.
     */
    private ArrayList<String> prepareCommenceReport()
    {
        ArrayList<String> commenceReport = new ArrayList<String>() ;
        
        String record ;
        int agentIndex ;
        String valueString ;
        
        //Include burn-in Relationships
        ArrayList<String> inputString = new ArrayList<String>() ;
        //LOGGER.info(Relationship.BURNIN_COMMENCE) ;
        record = prepareBurninRecord() ;
        if (!record.isEmpty())
            inputString.add(record + "clear:") ;
        
        // Read in Relationship commencements from simulation.
        for (boolean nextInput = true ; nextInput ; nextInput = updateReport() )
            for (String inputRecord : input)
                inputString.add(inputRecord) ;
        

        for (int reportNb = 0 ; reportNb < inputString.size() ; reportNb += outputCycle )
        {
            record = inputString.get(reportNb) ;
            int relationshipIdIndex = indexOfProperty(RELATIONSHIPID,record) ;
            int clearIndex = indexOfProperty("clear",record) ;
            if (relationshipIdIndex >= 0 && (relationshipIdIndex < clearIndex)) 
                commenceReport.add(record.substring(relationshipIdIndex,clearIndex)) ;
            else
                commenceReport.add("") ;
        }
        return commenceReport ;
    }
    
    /**
     * 
     * @return (String) replacement of Relationship.BURNIN_COMMENCE including only 
     * Relationships which have not broken up.
     */
    private String prepareBurninRecord()
    {
        
        String burninCommence = "" ;
        String burninCommenceStatic = Relationship.BURNIN_COMMENCE ;
        String burninBreakupStatic = Relationship.BURNIN_BREAKUP ;
        ArrayList<String> burninCommenceList ;
        ArrayList<Object> burninBreakup ;
        String relationshipId ;
        
        // Get relationshipIds commenced during burn-in
        if (burninBreakupStatic.isEmpty())    // If nothing in Relationship.BURNIN_COMMENCE
        {
            burninCommenceStatic = getMetaDatum("Relationship.BURNIN_COMMENCE") ;
            burninBreakupStatic = getMetaDatum("Relationship.BURNIN_BREAKUP") ;
        }
        burninCommenceList = extractArrayList(burninCommenceStatic,RELATIONSHIPID) ;
        burninBreakup = extractAllValues(RELATIONSHIPID,burninBreakupStatic,0) ;
        
        for (String relationshipEntry : burninCommenceList)
        {
            relationshipId = extractValue(RELATIONSHIPID,relationshipEntry) ;
            if (!burninBreakup.contains(relationshipId))
                burninCommence += relationshipEntry ;
        }
        
        //burninCommence += "clear:" ;
        return burninCommence ;
    }
    
}
